## Browser And System call

### 표준 라이브러리: 시스템의 차이를 감춘다.
- 원래 System Call은 모두 운영 체제와 매우 밀접한 관련이 있으며, 리눅스의 System Call은 윈도우의 System Call와 완전히 다릅니다.
- 사용자모드 Application에서 시스템 호출을 직접 사용하면 리눅스의 프로그램은 윈도우에서 직접 실행할 수 없게 됩니다. 
<br/> 따라서 우리는 사용자에게서 저수준 계층 간 차이를 감추는 일종의 표준이 필요합니다.
- 이것으로 프로그래머가 작성한 프로그램을 추가적인 수정 없이 서로 다른 운영 체제에서 실행할 수 있습니다.
- C 언어에서 이 일을 하는 것이 바로 표준 라이브러리 입니다.

- 표준라이브러리의 코드는 사용자상태에서도 실행됩니다. 
<br> 일반적으로 프로그래머는 표준 라이브러리를 호출하여 파일의 읽고 쓰기 작업과 네트워크 통신을 수행하며, 
<br> 표준 라이브러리는 실행 중인 운영 체제에 따라 대응되는 시스템 호출을 선택합니다.
- 계층적인 관점에서 보면, 전체 시스템 모습은 그림과 같이 햄버거 형태를 이루고 있습니다.
<table>
    <tbody>
        <tr>
            <td>응용 프로그램</td>
        </tr>
        <tr>
            <td>표준 라이브러리</td>
        </tr>
        <tr>
            <td>운영 체제</td>
        </tr>
        <tr>
            <td>하드웨어</td>
        </tr>
    </tbody>
</table>

- 고수준 계층에서는 응용 프로그램이 자리하고 있으며, 일반적으로 표준 라이브러리만 의사소통 대상으로 간주합니다.
- 표준 라이브러리는 시스템 호출로 운영 체제와 소통하며, 운영 체제는 저수준 하드웨어를 관리합니다.

## 더 알아보기

### Q. JavaScript 코드에서 XMLHttpRequest API 나 fetch API 를 사용하면 브라우저 프로세스가 System call을 호출하는가?
    - 브라우저 프로세스는 JS 요청을 위임받아 결국 OS 네트워크 시스템 콜을 수행합니다. → 따라서 “브라우저 프로세스가 시스템 콜을 호출한다”는 진술은 Yes (참) 입니다.

1. JavaScript 실행 단계
   - JS 코드가 fetch() 또는 XMLHttpRequest를 호출하면, 이 함수들은 JS 엔진(V8 등) 레벨에서는 단순히 비동기 요청을 등록하는 역할만 합니다.

2. 브라우저 네트워킹 스택 단계
   - JS 엔진은 브라우저의 내부 네트워킹 스레드(네트워크 서비스 또는 Network Service Process)에 요청을 전달 합니다.
   <br> 이 과정은 사용자 공간(user space)에서 진행 되며, 아직 커널 호출은 아닙니다.

3. OS 커널 호출 단계
   - 브라우저의 네트워킹 레이어(libcurl, Chromium net stack 등)는 실제로 TCP/IP 소켓을 열고 데이터를 송수신하기 위해 socket(), connect(), send(), recv(), close() 등의 시스템 콜을 호출합니다.
   <br> 이 단계에서 비로소 브라우저 프로세스가 OS 커널에 진입하게 됩니다.

4. 커널 → NIC(네트워크 인터페이스)
   - 커널 네트워크 스택이 패킷을 NIC 드라이버에 전달하면 물리적 네트워크 송신이 이루어집니다.