## ``` Consecutive Memory Locations ( 연속적인 메모리 배치 )에 관하여 ```


### WHY?

```text
프로그래밍 언어는 멤버 순서가 바뀌면 문제가 될 수도 있기 때문에 프로그래머가 지정한 멤버 순서를 지킨다. 
하지만 언어는 메모리 정렬도 지켜야 한다. 
따라서 연도를 4번째와 5번째 바이트에 위치시키면 경계에 걸치기 때문에 배치를 바꿔주어야 한다. 
프로그래밍 언어 도구는 패딩을 필요한 만큼 추가해 이 문제를 해결한다.

        - 한권으로 읽는 컴퓨터 구조와 프로그래밍 中 -
```
- 이 문단에서 ``` 언어는 메모리 정렬도 지켜야 한다 ```라는 구절이 이해가 잘 안되어 찾아보기 시작

### Content

- C/C++·Rust 같은 ```값 기반 메모리 모델``` 언어는 구조체 멤버를 선언된 순서 그대로 메모리에 배치
- 동시에 CPU가 데이터를 효율적으로 읽을 수 있도록 정렬 규칙(alignment rule)을 적용
  - ```각 자료형이 메모리에서 시작해야 하는 주소가 특정 배수 값이어야 한다``` 

<table>
    <thead>
        <td>타입</td> 
        <td>정렬 단위</td>
    </thead>
    <tbody>
        <tr>
            <td> char </td>
            <td>1 byte</td>
        </tr>
        <tr>
            <td> short </td>
            <td>2 bytes</td>
        </tr>
        <tr>
            <td> int </td>
            <td>4 bytes</td>
        </tr>
        <tr>
            <td> long, pointer </td>
            <td>8 bytes(64bit 기준)</td>
        </tr>
    </tbody>
</table>

- <b>즉, ```int``` 자료형 같은 경우 4의 배수 주소에서 시작해야 CPU가 한 번에 읽고 처리하기 쉽다는 것이 주요 골자</b>
- 그런데 ```프로그래밍 언어는 멤버 순서가 바뀌면 문제가 될 수도 있기 때문에 프로그래머가 지정한 멤버 순서를 지킨다.``` 라는 구절처럼 프로그래머가 지정한 순서대로 메모리에 배치되었을 때
<br/> 메모리상의 올바른 경계에 위치하지 않는다면 컴파일러(compiler)가 중간에 여분의 바이트(=패딩)을 삽입하여 위의 정렬 규칙을 맞춘다.
  - ```올바른 경계``` :  CPU는 한 번에 메모리를 읽고 쓰기 위해 정렬된 주소에서 시작하는 것을 기본으로 가정한다.

#### * 하지만 여기서 말하는 메모리상의 연속적인 배치는 물리 메모리에서의 배치를 뜻하는 것이 아닌 ( 당연하게도.. ) 가상 메모리상에서의 연속적인 배치를 의미한다..!!

#### * 그렇다면 가상메모리에서의 연속적인 배치가 어떤 의미가 있나?
- 실제로 CPU는 RAM을 직접 보지 않고 가상 주소 -> 캐시를 기준으로 동작

- CPU의 메모리 접근 흐름
  ```text
  CPU -> (가상 주소) -> TLB -> 캐시 라인 -> 메모리
  ```

* 데이터가 가상 주소에서 연속적이라면, CPU는 다음 데이터를 예측(prefetch) 하여 캐시 라인에 미리 가져온다.
* 캐시 라인은 보통 64바이트 단위 ... int 자료형 16개를 한 번에 캐싱 가능

## ```더 알아보기```

### 💥 TLB (Translation Lookaside Buffer) 란?
- 가상 메모리 주소 -> 물리 메모리 주소 변환을 빠르게 하기 위해 CPU 내부에 존재하는 작은 캐시 (*= 고속 주소변환 캐시)

* ```왜 필요한가 ?``` : OS는 <b>가상 메모리</b>를 사용하므로, 메모리에 접근할 때 TLB를 사용하지 않는다면 다음과 같은 과정이 필요
  ```text
  가상 주소 -> (페이지 테이블 조회) -> 물리 주소 -> 메모리 접근
  ```
  - 페이지 테이블은 RAM에 저장되기 때문에 캐시 메모리에 비하여 접근 속도가 느림...
  - 그래서 최근 사용된 주소 변환 결과를 TLB에 저장해두고 다음 접근 시 페이지 테이블 조회 없이 바로 물리 주소를 얻을 수 있다.